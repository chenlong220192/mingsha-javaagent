# 开发指南

## 概述

本文档为 mingsha-javaagent-methodtime 项目的开发者提供详细的开发指南，包括代码贡献规范、扩展开发、插件开发和测试编写等内容。

## 开发环境搭建

### 1. 环境要求
- **JDK**: 8+ (推荐 JDK 11+)
- **Maven**: 3.6+
- **IDE**: IntelliJ IDEA 或 Eclipse
- **Git**: 2.20+

### 2. 项目克隆
```bash
# 克隆项目
git clone <repository-url>
cd mingsha-javaagent-methodtime

# 安装依赖
mvn clean install
```

### 3. IDE 配置
```xml
<!-- .idea/codeStyles/Project.xml -->
<component name="ProjectCodeStyleConfiguration">
  <code_scheme name="Project" version="173">
    <JavaCodeStyleSettings>
      <option name="IMPORT_LAYOUT_TABLE">
        <value>
          <package name="java" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="javax" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="org" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="site.mingsha" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="" withSubpackages="true" static="false" />
        </value>
      </option>
    </JavaCodeStyleSettings>
  </code_scheme>
</component>
```

## 代码贡献规范

### 1. 代码风格

#### 1.1 命名规范
```java
// 类名：PascalCase
public class MethodTimeAgent {
    // 常量：UPPER_SNAKE_CASE
    public static final String CONFIG_FILE = "/agent-config.yml";
    
    // 静态变量：UPPER_SNAKE_CASE
    private static final Map<String, Object> CONFIG;
    
    // 实例变量：camelCase
    private String className;
    private long startTime;
    
    // 方法名：camelCase
    public void installAgent() {
        // 局部变量：camelCase
        String packageName = "com.example";
        long currentTime = System.nanoTime();
    }
}
```

#### 1.2 注释规范
```java
/**
 * 方法耗时采集记录。
 * Method time collection record.
 * 
 * 记录单个方法调用的详细信息，包括类名、方法名、执行时间等。
 * Records detailed information of a single method call, including class name, method name, execution time, etc.
 *
 * @author mingsha
 * @since 1.0.0
 */
public class MethodTimeRecord {
    /** 类名 | class name */
    public final String className;
    
    /** 方法名 | method name */
    public final String methodName;
    
    /**
     * 构造方法。
     * Constructor.
     * 
     * @param className 类名 | class name
     * @param methodName 方法名 | method name
     * @param startTime 开始时间 | start time
     * @param endTime 结束时间 | end time
     * @param durationNs 执行耗时（纳秒）| execution duration (nanoseconds)
     * @param threadName 线程名 | thread name
     * @param extraInfo 额外信息 | extra information
     */
    public MethodTimeRecord(String className, String methodName, 
                          long startTime, long endTime, long durationNs,
                          String threadName, String extraInfo) {
        this.className = className;
        this.methodName = methodName;
        // ... 其他字段初始化
    }
}
```

#### 1.3 异常处理
```java
/**
 * 安全的异常处理示例。
 * Safe exception handling example.
 */
public class SafeExceptionHandler {
    
    /**
     * 安全执行方法，捕获所有异常。
     * Safely execute method, catch all exceptions.
     * 
     * @param supplier 要执行的方法 | method to execute
     * @param defaultValue 默认返回值 | default return value
     * @return 执行结果或默认值 | execution result or default value
     */
    public static <T> T safeExecute(Supplier<T> supplier, T defaultValue) {
        try {
            return supplier.get();
        } catch (Exception e) {
            System.err.println("[mingsha-agent] 执行异常: " + e.getMessage());
            e.printStackTrace(System.err);
            return defaultValue;
        }
    }
    
    /**
     * 安全执行无返回值方法。
     * Safely execute void method.
     * 
     * @param runnable 要执行的方法 | method to execute
     */
    public static void safeExecute(Runnable runnable) {
        try {
            runnable.run();
        } catch (Exception e) {
            System.err.println("[mingsha-agent] 执行异常: " + e.getMessage());
            e.printStackTrace(System.err);
        }
    }
}
```

### 2. Git 提交规范

#### 2.1 提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

#### 2.2 提交类型
- **feat**: 新功能
- **fix**: 修复bug
- **docs**: 文档更新
- **style**: 代码格式调整
- **refactor**: 代码重构
- **test**: 测试相关
- **chore**: 构建过程或辅助工具的变动

#### 2.3 提交示例
```bash
# 新功能
feat(collector): 添加方法调用频率统计功能

# 修复bug
fix(storage): 修复H2数据库连接池泄漏问题

# 文档更新
docs(api): 更新API接口文档

# 代码重构
refactor(monitor): 重构CPU监控逻辑，提高性能

# 测试相关
test(unit): 添加MethodTimeBuffer单元测试
```

### 3. 代码审查

#### 3.1 审查清单
- [ ] 代码风格符合项目规范
- [ ] 添加了必要的注释和文档
- [ ] 包含适当的单元测试
- [ ] 异常处理完善
- [ ] 性能影响评估
- [ ] 安全性考虑

#### 3.2 审查流程
1. **自检**: 提交前进行自我检查
2. **代码审查**: 提交 Pull Request
3. **CI 检查**: 通过自动化测试
4. **合并**: 审查通过后合并到主分支

## 扩展开发指南

### 1. 存储插件开发

#### 1.1 存储接口定义
```java
/**
 * 存储插件接口。
 * Storage plugin interface.
 * 
 * 定义存储插件的基本接口，支持多种存储后端。
 * Defines basic interface for storage plugins, supporting multiple storage backends.
 *
 * @author mingsha
 */
public interface StoragePlugin {
    
    /**
     * 初始化存储插件。
     * Initialize storage plugin.
     * 
     * @throws Exception 初始化异常 | initialization exception
     */
    void init() throws Exception;
    
    /**
     * 批量插入方法耗时记录。
     * Batch insert method time records.
     * 
     * @param records 记录列表 | record list
     * @throws Exception 插入异常 | insert exception
     */
    void batchInsert(List<MethodTimeRecord> records) throws Exception;
    
    /**
     * 查询方法耗时统计。
     * Query method time statistics.
     * 
     * @param sql SQL查询语句 | SQL query
     * @return 查询结果 | query result
     * @throws Exception 查询异常 | query exception
     */
    List<Map<String, Object>> query(String sql) throws Exception;
    
    /**
     * 导出数据。
     * Export data.
     * 
     * @param filePath 导出文件路径 | export file path
     * @throws Exception 导出异常 | export exception
     */
    void export(String filePath) throws Exception;
    
    /**
     * 清理过期数据。
     * Clean expired data.
     * 
     * @param retentionDays 保留天数 | retention days
     * @throws Exception 清理异常 | cleanup exception
     */
    void cleanup(int retentionDays) throws Exception;
    
    /**
     * 关闭存储插件。
     * Close storage plugin.
     * 
     * @throws Exception 关闭异常 | close exception
     */
    void close() throws Exception;
}
```

#### 1.2 MySQL 存储插件实现
```java
/**
 * MySQL 存储插件实现。
 * MySQL storage plugin implementation.
 * 
 * 使用 MySQL 作为存储后端，支持高并发和大数据量。
 * Uses MySQL as storage backend, supports high concurrency and large data volume.
 *
 * @author mingsha
 */
public class MySQLStoragePlugin implements StoragePlugin {
    
    private static final String CREATE_TABLE_SQL = """
        CREATE TABLE IF NOT EXISTS method_time_stat (
            id BIGINT AUTO_INCREMENT PRIMARY KEY,
            class_name VARCHAR(255) NOT NULL,
            method_name VARCHAR(255) NOT NULL,
            start_time BIGINT NOT NULL,
            end_time BIGINT NOT NULL,
            duration_ns BIGINT NOT NULL,
            thread_name VARCHAR(128) NOT NULL,
            extra_info VARCHAR(512),
            create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            INDEX idx_class_method (class_name, method_name),
            INDEX idx_create_time (create_time),
            INDEX idx_duration (duration_ns)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
        """;
    
    private static final String INSERT_SQL = """
        INSERT INTO method_time_stat 
        (class_name, method_name, start_time, end_time, duration_ns, thread_name, extra_info)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """;
    
    private final String url;
    private final String username;
    private final String password;
    private final int maxPoolSize;
    private final int minPoolSize;
    
    private HikariDataSource dataSource;
    private Connection connection;
    
    public MySQLStoragePlugin(String url, String username, String password) {
        this(url, username, password, 20, 5);
    }
    
    public MySQLStoragePlugin(String url, String username, String password, 
                            int maxPoolSize, int minPoolSize) {
        this.url = url;
        this.username = username;
        this.password = password;
        this.maxPoolSize = maxPoolSize;
        this.minPoolSize = minPoolSize;
    }
    
    @Override
    public void init() throws Exception {
        // 配置连接池
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(maxPoolSize);
        config.setMinimumIdle(minPoolSize);
        config.setConnectionTimeout(30000);
        config.setIdleTimeout(600000);
        config.setMaxLifetime(1800000);
        config.setLeakDetectionThreshold(60000);
        
        dataSource = new HikariDataSource(config);
        connection = dataSource.getConnection();
        
        // 创建表
        try (Statement stmt = connection.createStatement()) {
            stmt.executeUpdate(CREATE_TABLE_SQL);
        }
        
        System.out.println("[mingsha-agent] MySQL 存储插件初始化成功");
    }
    
    @Override
    public void batchInsert(List<MethodTimeRecord> records) throws Exception {
        if (records.isEmpty()) {
            return;
        }
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(INSERT_SQL)) {
            
            conn.setAutoCommit(false);
            
            for (MethodTimeRecord record : records) {
                ps.setString(1, record.className);
                ps.setString(2, record.methodName);
                ps.setLong(3, record.startTime);
                ps.setLong(4, record.endTime);
                ps.setLong(5, record.durationNs);
                ps.setString(6, record.threadName);
                ps.setString(7, record.extraInfo);
                ps.addBatch();
            }
            
            ps.executeBatch();
            conn.commit();
        }
    }
    
    @Override
    public List<Map<String, Object>> query(String sql) throws Exception {
        List<Map<String, Object>> results = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            
            ResultSetMetaData metaData = rs.getMetaData();
            int columnCount = metaData.getColumnCount();
            
            while (rs.next()) {
                Map<String, Object> row = new HashMap<>();
                for (int i = 1; i <= columnCount; i++) {
                    String columnName = metaData.getColumnName(i);
                    Object value = rs.getObject(i);
                    row.put(columnName, value);
                }
                results.add(row);
            }
        }
        
        return results;
    }
    
    @Override
    public void export(String filePath) throws Exception {
        String exportSql = "SELECT * FROM method_time_stat ORDER BY create_time";
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(exportSql);
             FileWriter writer = new FileWriter(filePath)) {
            
            // 写入 CSV 头
            writer.write("id,class_name,method_name,start_time,end_time,duration_ns,thread_name,extra_info,create_time\n");
            
            // 写入数据
            while (rs.next()) {
                writer.write(String.format("%d,%s,%s,%d,%d,%d,%s,%s,%s\n",
                    rs.getLong("id"),
                    rs.getString("class_name"),
                    rs.getString("method_name"),
                    rs.getLong("start_time"),
                    rs.getLong("end_time"),
                    rs.getLong("duration_ns"),
                    rs.getString("thread_name"),
                    rs.getString("extra_info"),
                    rs.getTimestamp("create_time")
                ));
            }
        }
        
        System.out.println("[mingsha-agent] 数据导出完成: " + filePath);
    }
    
    @Override
    public void cleanup(int retentionDays) throws Exception {
        String cleanupSql = "DELETE FROM method_time_stat WHERE create_time < DATE_SUB(NOW(), INTERVAL ? DAY)";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement ps = conn.prepareStatement(cleanupSql)) {
            
            ps.setInt(1, retentionDays);
            int deletedRows = ps.executeUpdate();
            
            System.out.println("[mingsha-agent] 清理过期数据: " + deletedRows + " 行");
        }
    }
    
    @Override
    public void close() throws Exception {
        if (connection != null) {
            connection.close();
        }
        if (dataSource != null) {
            dataSource.close();
        }
        System.out.println("[mingsha-agent] MySQL 存储插件已关闭");
    }
}
```

### 2. 采集插件开发

#### 2.1 采集接口定义
```java
/**
 * 采集插件接口。
 * Collection plugin interface.
 * 
 * 定义采集插件的基本接口，支持自定义采集逻辑。
 * Defines basic interface for collection plugins, supporting custom collection logic.
 *
 * @author mingsha
 */
public interface CollectorPlugin {
    
    /**
     * 判断是否应该采集该方法。
     * Determine whether to collect this method.
     * 
     * @param className 类名 | class name
     * @param methodName 方法名 | method name
     * @param methodDesc 方法描述 | method description
     * @return true-采集，false-不采集 | true to collect, false to skip
     */
    boolean shouldCollect(String className, String methodName, String methodDesc);
    
    /**
     * 采集方法执行信息。
     * Collect method execution information.
     * 
     * @param className 类名 | class name
     * @param methodName 方法名 | method name
     * @param startTime 开始时间 | start time
     * @param endTime 结束时间 | end time
     * @param durationNs 执行耗时 | execution duration
     * @param threadName 线程名 | thread name
     * @return 采集记录 | collection record
     */
    MethodTimeRecord collect(String className, String methodName, 
                           long startTime, long endTime, long durationNs, String threadName);
    
    /**
     * 获取插件名称。
     * Get plugin name.
     * 
     * @return 插件名称 | plugin name
     */
    String getPluginName();
}
```

#### 2.2 慢方法采集插件
```java
/**
 * 慢方法采集插件。
 * Slow method collection plugin.
 * 
 * 专门采集执行时间超过阈值的慢方法。
 * Specifically collects slow methods that exceed the threshold.
 *
 * @author mingsha
 */
public class SlowMethodCollectorPlugin implements CollectorPlugin {
    
    private final long thresholdNs;
    private final double samplingRate;
    private final Random random = new Random();
    
    public SlowMethodCollectorPlugin(long thresholdNs, double samplingRate) {
        this.thresholdNs = thresholdNs;
        this.samplingRate = samplingRate;
    }
    
    @Override
    public boolean shouldCollect(String className, String methodName, String methodDesc) {
        // 采样率控制
        if (samplingRate < 1.0 && random.nextDouble() >= samplingRate) {
            return false;
        }
        
        // 过滤系统方法
        if (className.startsWith("java.") || className.startsWith("sun.")) {
            return false;
        }
        
        // 过滤特定方法
        if (methodName.equals("toString") || methodName.equals("hashCode") || 
            methodName.equals("equals") || methodName.equals("getClass")) {
            return false;
        }
        
        return true;
    }
    
    @Override
    public MethodTimeRecord collect(String className, String methodName, 
                                  long startTime, long endTime, long durationNs, String threadName) {
        // 只采集超过阈值的慢方法
        if (durationNs < thresholdNs) {
            return null;
        }
        
        // 添加额外信息
        String extraInfo = String.format("slow_method_threshold=%dns", thresholdNs);
        
        return new MethodTimeRecord(className, methodName, startTime, endTime, 
                                  durationNs, threadName, extraInfo);
    }
    
    @Override
    public String getPluginName() {
        return "SlowMethodCollector";
    }
}
```

### 3. 监控插件开发

#### 3.1 监控接口定义
```java
/**
 * 监控插件接口。
 * Monitoring plugin interface.
 * 
 * 定义监控插件的基本接口，支持自定义监控指标。
 * Defines basic interface for monitoring plugins, supporting custom monitoring metrics.
 *
 * @author mingsha
 */
public interface MonitorPlugin {
    
    /**
     * 初始化监控插件。
     * Initialize monitoring plugin.
     */
    void init();
    
    /**
     * 收集监控指标。
     * Collect monitoring metrics.
     * 
     * @return 监控指标 | monitoring metrics
     */
    Map<String, Object> collectMetrics();
    
    /**
     * 检查健康状态。
     * Check health status.
     * 
     * @return 健康状态 | health status
     */
    HealthStatus checkHealth();
    
    /**
     * 获取插件名称。
     * Get plugin name.
     * 
     * @return 插件名称 | plugin name
     */
    String getPluginName();
    
    /**
     * 关闭监控插件。
     * Close monitoring plugin.
     */
    void close();
}

/**
 * 健康状态枚举。
 * Health status enum.
 */
enum HealthStatus {
    HEALTHY,    // 健康
    WARNING,    // 警告
    CRITICAL    // 严重
}
```

#### 3.2 JVM 监控插件
```java
/**
 * JVM 监控插件。
 * JVM monitoring plugin.
 * 
 * 监控 JVM 相关指标，包括内存、GC、线程等。
 * Monitors JVM-related metrics, including memory, GC, threads, etc.
 *
 * @author mingsha
 */
public class JVMMonitorPlugin implements MonitorPlugin {
    
    private final MemoryMXBean memoryMXBean;
    private final ThreadMXBean threadMXBean;
    private final GarbageCollectorMXBean[] gcMXBeans;
    private final RuntimeMXBean runtimeMXBean;
    
    public JVMMonitorPlugin() {
        this.memoryMXBean = ManagementFactory.getMemoryMXBean();
        this.threadMXBean = ManagementFactory.getThreadMXBean();
        this.gcMXBeans = ManagementFactory.getGarbageCollectorMXBeans().toArray(new GarbageCollectorMXBean[0]);
        this.runtimeMXBean = ManagementFactory.getRuntimeMXBean();
    }
    
    @Override
    public void init() {
        System.out.println("[mingsha-agent] JVM 监控插件初始化成功");
    }
    
    @Override
    public Map<String, Object> collectMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // 内存指标
        MemoryUsage heapMemoryUsage = memoryMXBean.getHeapMemoryUsage();
        MemoryUsage nonHeapMemoryUsage = memoryMXBean.getNonHeapMemoryUsage();
        
        metrics.put("heap_used", heapMemoryUsage.getUsed());
        metrics.put("heap_max", heapMemoryUsage.getMax());
        metrics.put("heap_usage_ratio", (double) heapMemoryUsage.getUsed() / heapMemoryUsage.getMax());
        metrics.put("non_heap_used", nonHeapMemoryUsage.getUsed());
        
        // 线程指标
        metrics.put("thread_count", threadMXBean.getThreadCount());
        metrics.put("peak_thread_count", threadMXBean.getPeakThreadCount());
        metrics.put("daemon_thread_count", threadMXBean.getDaemonThreadCount());
        
        // GC 指标
        long totalGcCount = 0;
        long totalGcTime = 0;
        for (GarbageCollectorMXBean gcMXBean : gcMXBeans) {
            totalGcCount += gcMXBean.getCollectionCount();
            totalGcTime += gcMXBean.getCollectionTime();
        }
        metrics.put("gc_count", totalGcCount);
        metrics.put("gc_time", totalGcTime);
        
        // 运行时指标
        metrics.put("uptime", runtimeMXBean.getUptime());
        metrics.put("start_time", runtimeMXBean.getStartTime());
        
        return metrics;
    }
    
    @Override
    public HealthStatus checkHealth() {
        Map<String, Object> metrics = collectMetrics();
        
        double heapUsageRatio = (Double) metrics.get("heap_usage_ratio");
        int threadCount = (Integer) metrics.get("thread_count");
        
        if (heapUsageRatio > 0.9 || threadCount > 1000) {
            return HealthStatus.CRITICAL;
        } else if (heapUsageRatio > 0.8 || threadCount > 500) {
            return HealthStatus.WARNING;
        } else {
            return HealthStatus.HEALTHY;
        }
    }
    
    @Override
    public String getPluginName() {
        return "JVMMonitor";
    }
    
    @Override
    public void close() {
        System.out.println("[mingsha-agent] JVM 监控插件已关闭");
    }
}
```

## 测试编写指南

### 1. 单元测试

#### 1.1 测试框架配置
```xml
<!-- pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.2</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>4.11.0</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-junit-jupiter</artifactId>
        <version>4.11.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

#### 1.2 测试类结构
```java
/**
 * MethodTimeRecord 单元测试。
 * MethodTimeRecord unit tests.
 * 
 * 测试 MethodTimeRecord 类的各种功能。
 * Tests various functionalities of MethodTimeRecord class.
 *
 * @author mingsha
 */
@DisplayName("MethodTimeRecord 测试")
class MethodTimeRecordTest {
    
    private MethodTimeRecord record;
    private final String className = "com.example.TestClass";
    private final String methodName = "testMethod";
    private final long startTime = 1000000L;
    private final long endTime = 2000000L;
    private final long durationNs = 1000000L;
    private final String threadName = "test-thread";
    private final String extraInfo = "test-info";
    
    @BeforeEach
    void setUp() {
        record = new MethodTimeRecord(className, methodName, startTime, endTime, 
                                    durationNs, threadName, extraInfo);
    }
    
    @Test
    @DisplayName("构造方法测试")
    void testConstructor() {
        assertNotNull(record);
        assertEquals(className, record.className);
        assertEquals(methodName, record.methodName);
        assertEquals(startTime, record.startTime);
        assertEquals(endTime, record.endTime);
        assertEquals(durationNs, record.durationNs);
        assertEquals(threadName, record.threadName);
        assertEquals(extraInfo, record.extraInfo);
    }
    
    @Test
    @DisplayName("空参数测试")
    void testNullParameters() {
        MethodTimeRecord nullRecord = new MethodTimeRecord(null, null, 0, 0, 0, null, null);
        
        assertNull(nullRecord.className);
        assertNull(nullRecord.methodName);
        assertNull(nullRecord.threadName);
        assertNull(nullRecord.extraInfo);
        assertEquals(0, nullRecord.startTime);
        assertEquals(0, nullRecord.endTime);
        assertEquals(0, nullRecord.durationNs);
    }
    
    @Test
    @DisplayName("边界值测试")
    void testBoundaryValues() {
        // 测试最大值
        MethodTimeRecord maxRecord = new MethodTimeRecord(className, methodName, 
                                                        Long.MAX_VALUE, Long.MAX_VALUE, 
                                                        Long.MAX_VALUE, threadName, extraInfo);
        assertEquals(Long.MAX_VALUE, maxRecord.startTime);
        assertEquals(Long.MAX_VALUE, maxRecord.endTime);
        assertEquals(Long.MAX_VALUE, maxRecord.durationNs);
        
        // 测试最小值
        MethodTimeRecord minRecord = new MethodTimeRecord(className, methodName, 
                                                        Long.MIN_VALUE, Long.MIN_VALUE, 
                                                        Long.MIN_VALUE, threadName, extraInfo);
        assertEquals(Long.MIN_VALUE, minRecord.startTime);
        assertEquals(Long.MIN_VALUE, minRecord.endTime);
        assertEquals(Long.MIN_VALUE, minRecord.durationNs);
    }
    
    @ParameterizedTest
    @ValueSource(strings = {"", "a", "very-long-class-name-that-exceeds-normal-length"})
    @DisplayName("类名长度测试")
    void testClassNameLength(String testClassName) {
        MethodTimeRecord testRecord = new MethodTimeRecord(testClassName, methodName, 
                                                         startTime, endTime, durationNs, 
                                                         threadName, extraInfo);
        assertEquals(testClassName, testRecord.className);
    }
}
```

#### 1.3 Mock 测试示例
```java
/**
 * H2Storage Mock 测试。
 * H2Storage Mock tests.
 * 
 * 使用 Mockito 测试 H2Storage 类的功能。
 * Uses Mockito to test H2Storage class functionality.
 *
 * @author mingsha
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("H2Storage Mock 测试")
class H2StorageMockTest {
    
    @Mock
    private Connection mockConnection;
    
    @Mock
    private PreparedStatement mockPreparedStatement;
    
    @Mock
    private ResultSet mockResultSet;
    
    @InjectMocks
    private H2Storage h2Storage;
    
    @Test
    @DisplayName("批量插入测试")
    void testBatchInsert() throws Exception {
        // 准备测试数据
        List<MethodTimeRecord> records = Arrays.asList(
            new MethodTimeRecord("com.test.Class1", "method1", 1000, 2000, 1000, "thread1", ""),
            new MethodTimeRecord("com.test.Class2", "method2", 2000, 4000, 2000, "thread2", "")
        );
        
        // Mock 行为
        when(mockConnection.prepareStatement(anyString())).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.executeBatch()).thenReturn(new int[]{1, 1});
        
        // 执行测试
        h2Storage.batchInsert(records);
        
        // 验证调用
        verify(mockConnection).prepareStatement(contains("INSERT INTO"));
        verify(mockPreparedStatement, times(2)).addBatch();
        verify(mockPreparedStatement).executeBatch();
        verify(mockConnection).commit();
    }
    
    @Test
    @DisplayName("查询测试")
    void testQuery() throws Exception {
        // Mock 查询结果
        when(mockConnection.createStatement()).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.executeQuery(anyString())).thenReturn(mockResultSet);
        when(mockResultSet.next()).thenReturn(true, true, false);
        when(mockResultSet.getMetaData()).thenReturn(mock(ResultSetMetaData.class));
        when(mockResultSet.getMetaData().getColumnCount()).thenReturn(3);
        when(mockResultSet.getMetaData().getColumnName(1)).thenReturn("id");
        when(mockResultSet.getMetaData().getColumnName(2)).thenReturn("class_name");
        when(mockResultSet.getMetaData().getColumnName(3)).thenReturn("method_name");
        when(mockResultSet.getObject(1)).thenReturn(1L);
        when(mockResultSet.getObject(2)).thenReturn("com.test.Class");
        when(mockResultSet.getObject(3)).thenReturn("testMethod");
        
        // 执行测试
        List<Map<String, Object>> results = h2Storage.query("SELECT * FROM method_time_stat");
        
        // 验证结果
        assertNotNull(results);
        assertEquals(2, results.size());
        assertEquals(1L, results.get(0).get("id"));
        assertEquals("com.test.Class", results.get(0).get("class_name"));
    }
    
    @Test
    @DisplayName("异常处理测试")
    void testExceptionHandling() throws Exception {
        // Mock 异常
        when(mockConnection.prepareStatement(anyString())).thenThrow(new SQLException("Database error"));
        
        // 执行测试并验证异常
        assertThrows(SQLException.class, () -> {
            h2Storage.batchInsert(Arrays.asList(
                new MethodTimeRecord("com.test.Class", "method", 1000, 2000, 1000, "thread", "")
            ));
        });
    }
}
```

### 2. 集成测试

#### 2.1 测试容器配置
```java
/**
 * 集成测试基类。
 * Integration test base class.
 * 
 * 提供集成测试的基础设施。
 * Provides infrastructure for integration tests.
 *
 * @author mingsha
 */
@Testcontainers
@DisplayName("集成测试")
abstract class IntegrationTestBase {
    
    @Container
    protected static final PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
        .withDatabaseName("testdb")
        .withUsername("testuser")
        .withPassword("testpass");
    
    @Container
    protected static final MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
        .withDatabaseName("testdb")
        .withUsername("testuser")
        .withPassword("testpass");
    
    @BeforeAll
    static void setUp() {
        postgres.start();
        mysql.start();
    }
    
    @AfterAll
    static void tearDown() {
        postgres.stop();
        mysql.stop();
    }
}
```

#### 2.2 端到端测试
```java
/**
 * 端到端测试。
 * End-to-end tests.
 * 
 * 测试完整的 Agent 功能。
 * Tests complete Agent functionality.
 *
 * @author mingsha
 */
@DisplayName("端到端测试")
class EndToEndTest extends IntegrationTestBase {
    
    private Process targetProcess;
    private int telnetPort;
    
    @BeforeEach
    void setUp() throws Exception {
        // 启动目标应用
        ProcessBuilder pb = new ProcessBuilder(
            "java", "-javaagent:target/mingsha-javaagent-methodtime.jar",
            "-jar", "target/test-app.jar"
        );
        targetProcess = pb.start();
        
        // 等待应用启动
        Thread.sleep(5000);
        
        // 查找可用端口
        telnetPort = findAvailablePort(5005, 5010);
    }
    
    @AfterEach
    void tearDown() {
        if (targetProcess != null) {
            targetProcess.destroy();
        }
    }
    
    @Test
    @DisplayName("完整流程测试")
    void testCompleteFlow() throws Exception {
        // 1. 连接 Telnet
        Socket socket = new Socket("localhost", telnetPort);
        BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);
        
        // 2. 检查欢迎信息
        String welcome = reader.readLine();
        assertTrue(welcome.contains("欢迎使用 mingsha-agent"));
        
        // 3. 查看状态
        writer.println("agent status");
        String status = reader.readLine();
        assertTrue(status.contains("CPU:") || status.contains("内存:"));
        
        // 4. 执行查询
        writer.println("SELECT COUNT(*) FROM method_time_stat");
        String result = reader.readLine();
        assertNotNull(result);
        
        // 5. 导出数据
        writer.println("agent export /tmp/test_export.csv");
        String exportResult = reader.readLine();
        assertTrue(exportResult.contains("导出成功"));
        
        socket.close();
    }
    
    @Test
    @DisplayName("数据采集测试")
    void testDataCollection() throws Exception {
        // 1. 生成测试负载
        generateTestLoad();
        
        // 2. 等待数据采集
        Thread.sleep(10000);
        
        // 3. 验证数据
        try (Socket socket = new Socket("localhost", telnetPort);
             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
             PrintWriter writer = new PrintWriter(socket.getOutputStream(), true)) {
            
            writer.println("SELECT COUNT(*) FROM method_time_stat");
            String countResult = reader.readLine();
            int recordCount = Integer.parseInt(countResult.replaceAll("[^0-9]", ""));
            
            assertTrue(recordCount > 0, "应该有采集到的数据");
        }
    }
    
    private void generateTestLoad() {
        // 模拟应用负载
        for (int i = 0; i < 100; i++) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    private int findAvailablePort(int startPort, int endPort) {
        for (int port = startPort; port <= endPort; port++) {
            try (ServerSocket socket = new ServerSocket(port)) {
                return port;
            } catch (IOException e) {
                // 端口被占用，继续尝试下一个
            }
        }
        throw new RuntimeException("No available port found");
    }
}
```

### 3. 性能测试

#### 3.1 JMH 基准测试
```java
/**
 * 性能基准测试。
 * Performance benchmark tests.
 * 
 * 使用 JMH 进行性能测试。
 * Uses JMH for performance testing.
 *
 * @author mingsha
 */
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
@Fork(value = 1, warmups = 1)
@Warmup(iterations = 3, time = 1)
@Measurement(iterations = 5, time = 1)
@DisplayName("性能基准测试")
public class PerformanceBenchmark {
    
    private MethodTimeBuffer buffer;
    private List<MethodTimeRecord> testRecords;
    
    @Setup
    public void setUp() {
        buffer = new MethodTimeBuffer();
        testRecords = new ArrayList<>();
        
        for (int i = 0; i < 1000; i++) {
            testRecords.add(new MethodTimeRecord(
                "com.test.Class" + i,
                "method" + i,
                System.nanoTime(),
                System.nanoTime() + 1000,
                1000,
                "test-thread",
                ""
            ));
        }
    }
    
    @Benchmark
    @DisplayName("批量插入性能测试")
    public void testBatchInsert() {
        for (MethodTimeRecord record : testRecords) {
            buffer.offer(record);
        }
    }
    
    @Benchmark
    @DisplayName("批量消费性能测试")
    public void testBatchConsume() {
        buffer.pollBatch(100);
    }
    
    @Benchmark
    @DisplayName("并发插入性能测试")
    public void testConcurrentInsert() throws InterruptedException {
        int threadCount = 4;
        int recordsPerThread = 250;
        
        CountDownLatch latch = new CountDownLatch(threadCount);
        
        for (int i = 0; i < threadCount; i++) {
            final int threadId = i;
            new Thread(() -> {
                for (int j = 0; j < recordsPerThread; j++) {
                    MethodTimeRecord record = new MethodTimeRecord(
                        "com.test.Class" + threadId,
                        "method" + j,
                        System.nanoTime(),
                        System.nanoTime() + 1000,
                        1000,
                        "thread-" + threadId,
                        ""
                    );
                    buffer.offer(record);
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
    }
}
```

## 发布流程

### 1. 版本管理

#### 1.1 版本号规范
- **主版本号**: 不兼容的 API 修改
- **次版本号**: 向下兼容的功能性新增
- **修订号**: 向下兼容的问题修正

#### 1.2 发布检查清单
- [ ] 所有测试通过
- [ ] 代码审查完成
- [ ] 文档更新完成
- [ ] 版本号更新
- [ ] 变更日志更新
- [ ] 标签创建

### 2. 发布脚本
```bash
#!/bin/bash
# release.sh

set -e

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    exit 1
fi

echo "开始发布版本: $VERSION"

# 1. 更新版本号
mvn versions:set -DnewVersion=$VERSION

# 2. 运行测试
mvn clean test

# 3. 打包
mvn clean package

# 4. 创建 Git 标签
git add .
git commit -m "Release version $VERSION"
git tag -a "v$VERSION" -m "Release version $VERSION"

# 5. 推送到远程仓库
git push origin main
git push origin "v$VERSION"

echo "版本 $VERSION 发布完成"
```

## 贡献指南

### 1. 贡献流程
1. **Fork 项目**: 在 GitHub 上 Fork 项目
2. **创建分支**: 创建功能分支
3. **开发功能**: 实现新功能或修复 bug
4. **编写测试**: 添加相应的测试
5. **提交代码**: 提交代码并推送到分支
6. **创建 PR**: 创建 Pull Request
7. **代码审查**: 等待代码审查
8. **合并代码**: 审查通过后合并

### 2. 贡献模板
```markdown
## 描述
简要描述本次贡献的内容。

## 类型
- [ ] Bug 修复
- [ ] 新功能
- [ ] 文档更新
- [ ] 性能优化
- [ ] 重构

## 测试
- [ ] 单元测试已添加
- [ ] 集成测试已添加
- [ ] 所有测试通过

## 检查清单
- [ ] 代码符合项目规范
- [ ] 添加了必要的注释
- [ ] 更新了相关文档
- [ ] 没有引入新的警告

## 相关 Issue
Closes #123
```

### 3. 行为准则
- 尊重所有贡献者
- 保持专业和友好的交流
- 接受建设性的批评
- 关注项目的长期发展 