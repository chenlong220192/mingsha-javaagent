# 测试技术栈详解

## 概述

本项目采用现代化的测试技术栈，包括单元测试、集成测试、性能测试和代码覆盖率统计，确保代码质量和系统稳定性。

## 测试技术栈组成

### 1. 单元测试框架
- **JUnit 5.10.2**: 现代 Java 单元测试框架
- **Mockito 4.11.0**: Mock 测试框架
- **AssertJ**: 流式断言库（可选）

### 2. 集成测试框架
- **TestContainers 1.19.3**: 容器化集成测试
- **Awaitility 4.2.0**: 异步测试支持

### 3. 性能测试框架
- **JMH 1.37**: Java 微基准测试框架

### 4. 代码覆盖率
- **JaCoCo 0.8.11**: 代码覆盖率统计工具

## 单元测试详解

### 1. JUnit 5 特性应用

#### 测试生命周期注解
```java
@BeforeAll
public static void setup() {
    // 在所有测试方法执行前运行一次
    H2Storage.init();
}

@BeforeEach
public void setUp() {
    // 在每个测试方法执行前运行
    handler = new AgentExceptionHandler();
}

@AfterEach
public void tearDown() {
    // 在每个测试方法执行后运行
    System.setErr(originalErr);
}

@AfterAll
public static void cleanup() {
    // 在所有测试方法执行后运行一次
    H2Storage.close();
}
```

#### 参数化测试
```java
@ParameterizedTest
@ValueSource(strings = {"test1", "test2", "test3"})
public void testWithParameters(String input) {
    // 使用不同参数执行测试
    assertNotNull(input);
}
```

#### 断言示例
```java
@Test
public void testMethodTimeRecord() {
    MethodTimeRecord record = new MethodTimeRecord(
        "TestClass", "testMethod", 1000L, 2000L, 1000L, "main", ""
    );
    
    // 基本断言
    assertEquals("TestClass", record.className);
    assertEquals("testMethod", record.methodName);
    assertEquals(1000L, record.durationNs);
    
    // 异常断言
    assertDoesNotThrow(() -> {
        // 不应该抛出异常的代码
        handler.uncaughtException(thread, exception);
    });
    
    // 集合断言
    List<MethodTimeRecord> records = MethodTimeBuffer.pollBatch(10);
    assertNotNull(records);
    assertTrue(records.isEmpty());
}
```

### 2. Mockito 应用

#### Mock 对象创建
```java
@Test
public void testWithMock() {
    // 创建 Mock 对象
    Thread mockThread = mock(Thread.class);
    when(mockThread.getName()).thenReturn("test-thread");
    
    // 验证 Mock 调用
    verify(mockThread).getName();
}
```

#### 静态方法 Mock
```java
@Test
public void testStaticMethod() {
    try (MockedStatic<System> mockedSystem = mockStatic(System.class)) {
        mockedSystem.when(System::nanoTime).thenReturn(1000L);
        
        long time = System.nanoTime();
        assertEquals(1000L, time);
    }
}
```

#### Spy 对象
```java
@Test
public void testWithSpy() {
    // 创建部分 Mock 对象
    List<String> list = spy(new ArrayList<>());
    list.add("one");
    list.add("two");
    
    // Mock 特定方法
    when(list.size()).thenReturn(100);
    
    assertEquals(100, list.size());
    assertEquals("one", list.get(0));
}
```

## 集成测试详解

### 1. TestContainers 应用

#### 数据库集成测试
```java
@Testcontainers
public class DatabaseIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    @Test
    public void testDatabaseConnection() {
        // 使用容器化的数据库进行测试
        String jdbcUrl = postgres.getJdbcUrl();
        assertTrue(jdbcUrl.contains("testdb"));
    }
}
```

#### 网络服务集成测试
```java
@Testcontainers
public class TelnetIntegrationTest {
    
    @Container
    static GenericContainer<?> telnetServer = new GenericContainer<>("telnet-server:latest")
        .withExposedPorts(23);
    
    @Test
    public void testTelnetConnection() {
        String host = telnetServer.getHost();
        int port = telnetServer.getMappedPort(23);
        
        // 测试 Telnet 连接
        try (Socket socket = new Socket(host, port)) {
            assertTrue(socket.isConnected());
        }
    }
}
```

### 2. Awaitility 异步测试

#### 异步操作测试
```java
@Test
public void testAsyncOperation() {
    CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(1000);
            return "result";
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    });
    
    // 等待异步操作完成
    await().atMost(5, TimeUnit.SECONDS)
           .until(() -> future.isDone());
    
    assertEquals("result", future.get());
}
```

#### 条件等待测试
```java
@Test
public void testConditionalWait() {
    AtomicInteger counter = new AtomicInteger(0);
    
    // 启动后台线程增加计数器
    new Thread(() -> {
        for (int i = 0; i < 10; i++) {
            counter.incrementAndGet();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }).start();
    
    // 等待计数器达到指定值
    await().atMost(2, TimeUnit.SECONDS)
           .until(() -> counter.get() >= 5);
    
    assertTrue(counter.get() >= 5);
}
```

## 性能测试详解

### 1. JMH 微基准测试

#### 基本性能测试
```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@State(Scope.Benchmark)
public class MethodTimeBufferBenchmark {
    
    private MethodTimeRecord record;
    
    @Setup
    public void setup() {
        record = new MethodTimeRecord(
            "TestClass", "testMethod", 1000L, 2000L, 1000L, "main", ""
        );
    }
    
    @Benchmark
    public boolean testOffer() {
        return MethodTimeBuffer.offer(record);
    }
    
    @Benchmark
    public List<MethodTimeRecord> testPollBatch() {
        return MethodTimeBuffer.pollBatch(100);
    }
}
```

#### 参数化性能测试
```java
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class BatchSizeBenchmark {
    
    @Param({"10", "100", "1000"})
    public int batchSize;
    
    @Benchmark
    public void testBatchInsert() {
        List<MethodTimeRecord> batch = new ArrayList<>();
        for (int i = 0; i < batchSize; i++) {
            batch.add(new MethodTimeRecord(
                "TestClass", "testMethod", 1000L, 2000L, 1000L, "main", ""
            ));
        }
        H2Storage.batchInsert(batch);
    }
}
```

### 2. 性能测试配置

#### Maven 配置
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.4</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <finalName>benchmarks</finalName>
                <transformers>
                    <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                        <mainClass>org.openjdk.jmh.Main</mainClass>
                    </transformer>
                </transformers>
            </configuration>
        </execution>
    </executions>
</plugin>
```

#### 运行性能测试
```bash
# 编译并运行性能测试
mvn clean package
java -jar target/benchmarks.jar

# 运行特定测试
java -jar target/benchmarks.jar MethodTimeBufferBenchmark

# 生成报告
java -jar target/benchmarks.jar -rf json -rff results.json
```

## 代码覆盖率详解

### 1. JaCoCo 配置

#### Maven 插件配置
```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.11</version>
    <executions>
        <execution>
            <id>prepare-agent</id>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
        <execution>
            <id>check</id>
            <goals>
                <goal>check</goal>
            </goals>
            <configuration>
                <rules>
                    <rule>
                        <element>BUNDLE</element>
                        <limits>
                            <limit>
                                <counter>LINE</counter>
                                <value>COVEREDRATIO</value>
                                <minimum>0.80</minimum>
                            </limit>
                            <limit>
                                <counter>BRANCH</counter>
                                <value>COVEREDRATIO</value>
                                <minimum>0.70</minimum>
                            </limit>
                        </limits>
                    </rule>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

### 2. 覆盖率报告

#### 生成覆盖率报告
```bash
# 运行测试并生成覆盖率报告
mvn clean test

# 查看 HTML 报告
open target/site/jacoco/index.html

# 生成 XML 报告
mvn jacoco:report
```

#### 覆盖率指标
- **行覆盖率 (Line Coverage)**: 目标 80%
- **分支覆盖率 (Branch Coverage)**: 目标 70%
- **方法覆盖率 (Method Coverage)**: 目标 90%
- **类覆盖率 (Class Coverage)**: 目标 100%

## 测试最佳实践

### 1. 测试命名规范
```java
// 使用描述性的测试方法名
@Test
public void shouldReturnTrueWhenValidInputProvided() {
    // 测试实现
}

@Test
public void shouldThrowExceptionWhenInvalidInputProvided() {
    // 测试实现
}
```

### 2. 测试结构 (AAA 模式)
```java
@Test
public void testMethodBehavior() {
    // Arrange (准备)
    MethodTimeRecord record = new MethodTimeRecord(
        "TestClass", "testMethod", 1000L, 2000L, 1000L, "main", ""
    );
    
    // Act (执行)
    boolean result = MethodTimeBuffer.offer(record);
    
    // Assert (断言)
    assertTrue(result);
    assertEquals(1, MethodTimeBuffer.size());
}
```

### 3. 测试隔离
```java
@BeforeEach
public void setUp() {
    // 每个测试前重置状态
    MethodTimeBuffer.resetQueueForTest(1000);
}

@AfterEach
public void tearDown() {
    // 每个测试后清理资源
    MethodTimeBuffer.resetQueueForTest(1000);
}
```

### 4. 测试数据管理
```java
// 使用测试工厂方法
public class TestDataFactory {
    public static MethodTimeRecord createTestRecord() {
        return new MethodTimeRecord(
            "TestClass", "testMethod", 1000L, 2000L, 1000L, "main", ""
        );
    }
    
    public static List<MethodTimeRecord> createTestBatch(int size) {
        List<MethodTimeRecord> batch = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            batch.add(createTestRecord());
        }
        return batch;
    }
}
```

## 持续集成测试

### 1. CI/CD 配置
```yaml
# GitHub Actions 示例
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up JDK 8
        uses: actions/setup-java@v2
        with:
          java-version: '8'
      - name: Run tests
        run: mvn clean test
      - name: Upload coverage
        uses: codecov/codecov-action@v1
```

### 2. 测试报告集成
```xml
<!-- 集成测试报告插件 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-report-plugin</artifactId>
    <version>3.0.0</version>
    <configuration>
        <outputDirectory>target/site</outputDirectory>
        <reportsDirectory>target/surefire-reports</reportsDirectory>
    </configuration>
</plugin>
```

## 扩展阅读

- [JUnit 5 官方文档](https://junit.org/junit5/docs/current/user-guide/)
- [Mockito 官方文档](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- [TestContainers 官方文档](https://www.testcontainers.org/)
- [JMH 官方文档](http://openjdk.java.net/projects/code-tools/jmh/)
- [JaCoCo 官方文档](https://www.jacoco.org/jacoco/trunk/doc/) 