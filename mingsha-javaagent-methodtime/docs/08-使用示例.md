# 使用示例文档

## 概述

本文档提供 mingsha-javaagent-methodtime 的各种使用场景示例，包括配置示例、最佳实践和常见使用模式。

## 快速开始示例

### 1. 基础使用
```bash
# 1. 打包项目
mvn clean package

# 2. 启动目标应用（以 Spring Boot 为例）
java -javaagent:target/mingsha-javaagent-methodtime.jar -jar your-app.jar

# 3. 连接管理端口
telnet localhost 5005

# 4. 查看状态
agent status
```

### 2. 配置文件示例
```yaml
# agent-config.yml
collector:
  packages: "com.example.*"   # 采集指定包
  samplingRate: 1.0           # 全量采集
  minDurationNs: 100000       # 最小耗时100微秒
  queueCapacity: 10000        # 队列容量

storage:
  batchSize: 500              # 批量写入
  h2:
    path: "./mingsha_javaagent_method_time_h2_db"  # 数据库路径

manage:
  telnet:
    port: 5005                # 管理端口

monitor:
  cpu:
    fuseThreshold: 80         # CPU熔断阈值
```

## 不同场景配置示例

### 1. 生产环境配置
```yaml
collector:
  packages: "com.company.production.*"
  samplingRate: 0.1           # 10%采样，降低性能影响
  minDurationNs: 1000000      # 只采集超过1ms的方法
  queueCapacity: 50000        # 大容量队列

storage:
  batchSize: 1000             # 大批量写入
  retentionDays: 30           # 保留30天
  retentionRows: 10000000     # 最多1000万条记录

monitor:
  cpu:
    fuseThreshold: 70         # 更严格的CPU限制
  healthCheckIntervalMs: 3000 # 更频繁的健康检查
```

### 2. 开发环境配置
```yaml
collector:
  packages: "com.company.*"
  samplingRate: 1.0           # 全量采集
  minDurationNs: 10000        # 采集所有方法
  queueCapacity: 1000         # 小容量队列

storage:
  batchSize: 100              # 小批量写入
  retentionDays: 7            # 保留7天
  retentionRows: 100000       # 最多10万条记录

log:
  level: DEBUG                # 详细日志
```

### 3. 性能测试配置
```yaml
collector:
  packages: "com.company.critical.*"
  samplingRate: 0.5           # 50%采样
  minDurationNs: 50000        # 50微秒阈值
  queueCapacity: 100000       # 大容量队列

storage:
  batchSize: 2000             # 大批量写入
  retentionDays: 1            # 只保留1天
  retentionRows: 5000000      # 500万条记录

monitor:
  cpu:
    fuseThreshold: 90         # 高CPU阈值
```

## 常见使用模式

### 1. 慢方法分析
```bash
# 1. 配置采集所有方法
collector:
  packages: "com.example.*"
  samplingRate: 1.0
  minDurationNs: 0

# 2. 运行应用一段时间

# 3. 查询慢方法
telnet localhost 5005
SELECT class_name, method_name, AVG(duration_ns) as avg_duration, COUNT(*) as call_count 
FROM method_time_stat 
WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP) 
GROUP BY class_name, method_name 
HAVING avg_duration > 1000000 
ORDER BY avg_duration DESC
```

### 2. 线程性能分析
```bash
# 查询线程性能统计
SELECT 
    thread_name,
    COUNT(*) as call_count,
    AVG(duration_ns) as avg_duration,
    MAX(duration_ns) as max_duration,
    MIN(duration_ns) as min_duration
FROM method_time_stat 
WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)
GROUP BY thread_name 
ORDER BY avg_duration DESC
```

### 3. 方法调用频率分析
```bash
# 查询方法调用频率
SELECT 
    class_name,
    method_name,
    COUNT(*) as call_count,
    COUNT(*) * 1.0 / (SELECT COUNT(*) FROM method_time_stat WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)) as call_ratio
FROM method_time_stat 
WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)
GROUP BY class_name, method_name 
ORDER BY call_count DESC
```

### 4. 性能趋势分析
```bash
# 按时间分析性能趋势
SELECT 
    DATE_FORMAT(create_time, '%Y-%m-%d %H:00:00') as hour,
    COUNT(*) as call_count,
    AVG(duration_ns) as avg_duration,
    MAX(duration_ns) as max_duration
FROM method_time_stat 
WHERE create_time > DATEADD('DAY', -1, CURRENT_TIMESTAMP)
GROUP BY DATE_FORMAT(create_time, '%Y-%m-%d %H:00:00')
ORDER BY hour
```

## 最佳实践案例

### 1. 微服务性能监控
```yaml
# 微服务配置示例
collector:
  packages: "com.microservice.*"
  samplingRate: 0.2           # 20%采样
  minDurationNs: 500000       # 0.5ms阈值

storage:
  batchSize: 500
  retentionDays: 7
  h2:
    path: "/data/mingsha_javaagent_method_time_h2_db"

monitor:
  cpu:
    fuseThreshold: 75
```

### 2. Web应用性能分析
```yaml
# Web应用配置示例
collector:
  packages: "com.webapp.controller.*,com.webapp.service.*"
  samplingRate: 1.0           # 全量采集关键路径
  minDurationNs: 100000       # 100微秒阈值

storage:
  batchSize: 1000
  retentionDays: 14           # 保留2周
```

### 3. 数据库操作监控
```yaml
# 数据库操作监控配置
collector:
  packages: "com.dao.*,com.repository.*"
  samplingRate: 1.0           # 全量采集数据库操作
  minDurationNs: 0            # 采集所有数据库操作

storage:
  batchSize: 200
  retentionDays: 30           # 长期保留
```

## 故障排查示例

### 1. 性能问题排查
```bash
# 1. 检查Agent状态
agent status

# 2. 查看异常统计
agent errors

# 3. 分析慢方法
SELECT class_name, method_name, duration_ns, thread_name, create_time
FROM method_time_stat 
WHERE duration_ns > 10000000  # 超过10ms的方法
ORDER BY duration_ns DESC
LIMIT 20

# 4. 检查线程状态
SELECT thread_name, COUNT(*) as call_count, AVG(duration_ns) as avg_duration
FROM method_time_stat 
WHERE create_time > DATEADD('MINUTE', -10, CURRENT_TIMESTAMP)
GROUP BY thread_name
ORDER BY avg_duration DESC
```

### 2. 数据丢失排查
```bash
# 1. 检查数据丢失统计
agent errors

# 2. 检查队列状态
agent status

# 3. 检查本地转存文件
ls -la *.csv

# 4. 手动补偿数据
# 查看补偿日志，确认数据是否已重新入库
```

### 3. 配置问题排查
```bash
# 1. 检查配置是否正确加载
agent reload

# 2. 验证采集包配置
# 查看是否有数据采集到指定包的方法

# 3. 检查端口配置
# 确认Telnet端口是否可访问
telnet localhost 5005
```

## 自动化脚本示例

### 1. 监控脚本
```bash
#!/bin/bash
# monitor.sh - 自动化监控脚本

HOST="localhost"
PORT="5005"
LOG_FILE="/var/log/method_time_monitor.log"

# 执行监控命令
monitor() {
    telnet $HOST $PORT << EOF | tee -a $LOG_FILE
agent status
agent errors
SELECT COUNT(*) as total_calls FROM method_time_stat WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)
SELECT AVG(duration_ns) as avg_duration FROM method_time_stat WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)
quit
EOF
}

# 每小时执行一次
while true; do
    echo "$(date): 开始监控检查" >> $LOG_FILE
    monitor
    sleep 3600
done
```

### 2. 数据导出脚本
```bash
#!/bin/bash
# export_data.sh - 数据导出脚本

HOST="localhost"
PORT="5005"
EXPORT_DIR="/data/exports"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建导出目录
mkdir -p $EXPORT_DIR

# 导出数据
telnet $HOST $PORT << EOF
agent export $EXPORT_DIR/method_time_$DATE.csv
quit
EOF

echo "数据已导出到: $EXPORT_DIR/method_time_$DATE.csv"
```

### 3. 性能分析脚本
```bash
#!/bin/bash
# analyze_performance.sh - 性能分析脚本

HOST="localhost"
PORT="5005"
OUTPUT_FILE="/tmp/performance_analysis_$(date +%Y%m%d_%H%M%S).txt"

# 执行性能分析
telnet $HOST $PORT << EOF > $OUTPUT_FILE
SELECT 
    class_name,
    method_name,
    COUNT(*) as call_count,
    AVG(duration_ns) as avg_duration,
    MAX(duration_ns) as max_duration,
    MIN(duration_ns) as min_duration
FROM method_time_stat 
WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)
GROUP BY class_name, method_name 
HAVING avg_duration > 1000000
ORDER BY avg_duration DESC
quit
EOF

echo "性能分析结果已保存到: $OUTPUT_FILE"
```

## 集成示例

### 1. 与 Prometheus 集成
```yaml
# prometheus.yml 配置
scrape_configs:
  - job_name: 'method-time-agent'
    static_configs:
      - targets: ['localhost:5005']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

### 2. 与 Grafana 集成
```sql
-- Grafana 查询示例
SELECT 
    $__time(create_time),
    AVG(duration_ns) as avg_duration
FROM method_time_stat 
WHERE create_time >= $__timeFrom() AND create_time <= $__timeTo()
GROUP BY $__timeGroup(create_time, '1m')
ORDER BY create_time
```

### 3. 与 ELK 集成
```json
// Logstash 配置示例
input {
  file {
    path => "/var/log/method_time_*.csv"
    start_position => "beginning"
  }
}

filter {
  csv {
    columns => ["id", "class_name", "method_name", "duration_ns", "thread_name", "create_time"]
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "method-time-%{+YYYY.MM.dd}"
  }
}
``` 