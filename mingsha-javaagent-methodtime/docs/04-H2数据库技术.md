# H2 数据库技术详解

## 概述

H2 是一个轻量级的嵌入式数据库引擎，本项目使用 H2 2.2.224 版本作为方法耗时数据的存储引擎，提供高性能的数据存储和查询能力。

## H2 数据库特性

### 1. 核心特性
- **嵌入式**: 无需单独安装，直接集成到应用中
- **内存模式**: 支持纯内存数据库，性能极高
- **文件模式**: 支持持久化到文件系统
- **兼容性**: 支持标准 SQL 和 JDBC API
- **多模式**: 支持单用户和多用户模式

### 2. 性能优势
- **启动快速**: 毫秒级启动时间
- **内存占用小**: 运行时内存占用低
- **查询性能高**: 内存数据库查询性能优异
- **并发支持**: 支持多线程并发访问

## 项目中的 H2 应用

### 1. 数据库配置

#### 连接配置
```java
// H2 数据库连接 URL
private static final String DB_URL = "jdbc:h2:file:" + AgentConfig.getH2Path() + ";AUTO_SERVER=TRUE";

// 连接参数
private static final String USER = "sa";
private static final String PASSWORD = "";
```

#### 配置说明
- **file 模式**: 数据持久化到文件系统
- **AUTO_SERVER=TRUE**: 支持多进程访问
- **配置化路径**: 通过 `AgentConfig.getH2Path()` 获取数据库路径

### 2. 表结构设计

#### method_time_stat 表结构
```sql
CREATE TABLE IF NOT EXISTS method_time_stat (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,           -- 主键ID
    class_name VARCHAR(255),                        -- 类名
    method_name VARCHAR(255),                       -- 方法名
    start_time BIGINT,                              -- 开始时间（纳秒）
    end_time BIGINT,                                -- 结束时间（纳秒）
    duration_ns BIGINT,                             -- 执行耗时（纳秒）
    thread_name VARCHAR(128),                       -- 线程名
    extra_info VARCHAR(512),                        -- 额外信息
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- 创建时间
);
```

#### 索引优化
```sql
-- 建议的索引（可根据查询模式调整）
CREATE INDEX idx_class_method ON method_time_stat(class_name, method_name);
CREATE INDEX idx_duration ON method_time_stat(duration_ns);
CREATE INDEX idx_create_time ON method_time_stat(create_time);
CREATE INDEX idx_thread ON method_time_stat(thread_name);
```

### 3. 核心功能实现

#### 数据库初始化
```java
public static void init() throws SQLException {
    // 1. 建立数据库连接
    conn = DriverManager.getConnection(DB_URL, USER, PASSWORD);
    
    // 2. 自动建表
    try (Statement stmt = conn.createStatement()) {
        stmt.executeUpdate("CREATE TABLE IF NOT EXISTS " + TABLE + " (" +
                "id BIGINT AUTO_INCREMENT PRIMARY KEY, " +
                "class_name VARCHAR(255), " +
                "method_name VARCHAR(255), " +
                "start_time BIGINT, " +
                "end_time BIGINT, " +
                "duration_ns BIGINT, " +
                "thread_name VARCHAR(128), " +
                "extra_info VARCHAR(512), " +
                "create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP)");
    }
}
```

#### 批量写入优化
```java
public static void batchInsert(List<MethodTimeRecord> records) {
    if (records == null || records.isEmpty()) return;
    
    String sql = "INSERT INTO " + TABLE + 
                 " (class_name, method_name, start_time, end_time, duration_ns, thread_name, extra_info) " +
                 "VALUES (?, ?, ?, ?, ?, ?, ?)";
    
    try (PreparedStatement ps = conn.prepareStatement(sql)) {
        for (MethodTimeRecord r : records) {
            ps.setString(1, r.className);
            ps.setString(2, r.methodName);
            ps.setLong(3, r.startTime);
            ps.setLong(4, r.endTime);
            ps.setLong(5, r.durationNs);
            ps.setString(6, r.threadName);
            ps.setString(7, r.extraInfo);
            ps.addBatch();
        }
        ps.executeBatch();
    } catch (SQLException e) {
        // 失败转存本地文件
        saveToLocal(records);
    }
}
```

#### 数据清理策略
```java
public static void cleanHistory() {
    try (Statement stmt = conn.createStatement()) {
        // 1. 按天数清理
        int days = AgentConfig.getRetentionDays();
        stmt.executeUpdate("DELETE FROM " + TABLE + 
                          " WHERE create_time < DATEADD('DAY', -" + days + ", CURRENT_TIMESTAMP)");
        
        // 2. 按最大条数清理
        int rows = AgentConfig.getRetentionRows();
        stmt.executeUpdate("DELETE FROM " + TABLE + 
                          " WHERE id NOT IN (SELECT id FROM " + TABLE + 
                          " ORDER BY id DESC LIMIT " + rows + ")");
    } catch (SQLException e) {
        System.err.println("[mingsha-agent][清理] H2历史数据清理异常: " + e.getMessage());
    }
}
```

## 性能优化策略

### 1. 批量操作优化
- **批量插入**: 使用 `PreparedStatement.addBatch()` 减少网络往返
- **批量大小**: 通过 `AgentConfig.getBatchSize()` 配置批量大小
- **事务控制**: 批量操作在单个事务中执行

### 2. 连接池管理
- **单例连接**: 使用静态连接避免频繁创建
- **连接复用**: 多个操作复用同一个连接
- **异常处理**: 连接异常时自动重连

### 3. 查询优化
- **索引使用**: 为常用查询字段创建索引
- **分页查询**: 大结果集使用分页查询
- **查询缓存**: 对重复查询结果进行缓存

### 4. 存储优化
- **数据类型**: 使用合适的数据类型减少存储空间
- **压缩**: 启用 H2 压缩功能减少文件大小
- **分区**: 按时间分区提高查询性能

## 数据安全与可靠性

### 1. 数据备份
```java
// 自动备份策略
public static void backup() {
    try (Connection backupConn = DriverManager.getConnection(DB_URL + ";BACKUP_TO=backup.zip")) {
        // H2 自动备份到指定文件
    } catch (SQLException e) {
        System.err.println("备份失败: " + e.getMessage());
    }
}
```

### 2. 失败转存
```java
private static void saveToLocal(List<MethodTimeRecord> records) {
    String file = "method_time_backup_" + System.currentTimeMillis() + ".csv";
    try (FileWriter fw = new FileWriter(file, true)) {
        for (MethodTimeRecord r : records) {
            fw.write(String.format("%s,%s,%d,%d,%d,%s,%s\n",
                    r.className, r.methodName, r.startTime, r.endTime, 
                    r.durationNs, r.threadName, r.extraInfo));
        }
    } catch (IOException ignore) {
        // 记录转存失败
    }
}
```

### 3. 自动补偿
```java
public static void compensateLocalFiles() {
    File dir = new File(".");
    File[] files = dir.listFiles((d, name) -> 
        name.startsWith("method_time_backup_") && name.endsWith(".csv"));
    
    if (files == null) return;
    
    for (File file : files) {
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            ArrayList<MethodTimeRecord> batch = new ArrayList<>();
            
            while ((line = br.readLine()) != null) {
                String[] arr = line.split(",", 7);
                if (arr.length == 7) {
                    batch.add(new MethodTimeRecord(arr[0], arr[1], 
                        Long.parseLong(arr[2]), Long.parseLong(arr[3]), 
                        Long.parseLong(arr[4]), arr[5], arr[6]));
                }
                
                if (batch.size() >= AgentConfig.getBatchSize()) {
                    batchInsert(batch);
                    batch.clear();
                }
            }
            
            if (!batch.isEmpty()) {
                batchInsert(batch);
            }
            
            // 补偿成功后删除文件
            if (file.delete()) {
                System.out.println("[mingsha-agent][补偿] 已成功补偿并删除 " + file.getName());
            }
        } catch (Exception e) {
            System.err.println("[mingsha-agent][补偿] 补偿文件 " + file.getName() + " 失败: " + e.getMessage());
        }
    }
}
```

## 监控与维护

### 1. 数据库状态监控
```java
public static String getDatabaseStatus() {
    try (Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery("SELECT COUNT(*) as total FROM " + TABLE)) {
        
        if (rs.next()) {
            long total = rs.getLong("total");
            return String.format("数据库记录总数: %d", total);
        }
    } catch (SQLException e) {
        return "数据库状态查询失败: " + e.getMessage();
    }
    return "数据库状态未知";
}
```

### 2. 性能监控
```java
public static void monitorPerformance() {
    try (Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery(
             "SELECT AVG(duration_ns) as avg_duration, " +
             "MAX(duration_ns) as max_duration, " +
             "COUNT(*) as total_count " +
             "FROM " + TABLE + " WHERE create_time > DATEADD('HOUR', -1, CURRENT_TIMESTAMP)")) {
        
        if (rs.next()) {
            long avgDuration = rs.getLong("avg_duration");
            long maxDuration = rs.getLong("max_duration");
            long totalCount = rs.getLong("total_count");
            
            System.out.printf("[H2监控] 1小时内: 平均耗时=%dns, 最大耗时=%dns, 总记录数=%d\n",
                avgDuration, maxDuration, totalCount);
        }
    } catch (SQLException e) {
        System.err.println("性能监控失败: " + e.getMessage());
    }
}
```

## 最佳实践

### 1. 配置优化
- **内存设置**: 根据数据量调整 H2 内存参数
- **缓存设置**: 启用查询缓存提高性能
- **压缩设置**: 启用数据压缩减少存储空间

### 2. 维护策略
- **定期清理**: 设置自动清理任务
- **定期备份**: 定期备份重要数据
- **性能监控**: 监控数据库性能指标

### 3. 故障处理
- **连接异常**: 自动重连机制
- **写入失败**: 失败转存本地文件
- **数据恢复**: 自动补偿机制

## 扩展阅读

- [H2 数据库官方文档](http://www.h2database.com/html/main.html)
- [H2 性能调优指南](http://www.h2database.com/html/performance.html)
- [H2 最佳实践](http://www.h2database.com/html/best-practices.html) 